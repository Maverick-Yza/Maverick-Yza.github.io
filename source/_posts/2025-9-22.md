---
title: 2025.9.22
date: 2025-09-22 12:04:09
tags:
---
# Overview
1. 9.17--9.21 总结与反思
2. 学习了本周以及假期的课件

## 9.17--9.21 总结与反思
过去几天有点放纵了，还是有点没克服因为一些身体上的原因而不影响状态，而且接下来必须做到睡前不看手机，并且需要注意在进行了比较剧烈的运动的当晚就要早点休息以防影响第二天的状态。  
过去几天摩羯身上也接连出现状况导致心情有点受影响，不过现在我感觉我找到了担心的分界线，其实主要就是保持毛发和环境的干净，除此之外只要不是持续几天的异常都没必要太过担心。  
不过还是有一些好事情发生的，比如：上周末通知了我的节目被通过了，这次一定要不留遗憾的表演成功；此外各个社团的招新也结束了，这周总算可以开始社团活动了，期待遇见优秀的人吧；最后唯一在过去几天里完成不错的就是依旧保持每天背单词了，总算一天不落的完成了开学打卡，期待下一次累签。
## 课件知识点

### 数据科学（统计）
**核心目标：想要找到一个适合工业数据的模型，以实现两大功能
—— `解释数据背后的现象、对新场景下的行为进行预测`**
1. 数据拟合核心内容
   2. 拟合目标：建立自变量（如质量）与因变量（如距离）的关系，找到最优拟合曲线
   3. 拟合评估指标：
      4. 最小二乘法目标函数：计算观测值与预测值差值平方和，最小化该值即最小化方差
      5. 平均均方误差：衡量模型拟合误差，公式为（误差总和/数据长度）
      6. 决定系数R²：反映模型对数据变异性的解释能力，越接近1代表模型越能解释数据的底层逻辑
   7. 多项式拟合时用到的拟合工具：Python pylab库函数，polyfit（求n次多项式系数，如n=1求直线系数）、polyval（根据模型计算预测值）
8. 模型选择的关键矛盾：拟合优度与泛化能力
   9. 高阶模型的 “虚假优势” -- 虽然在案例中的16 次多项式在训练数据上的R^2最高，但其并不能代表模型对新数据的适配能力（即泛化能力）
      10. 矛盾现象的根本原因：源于训练误差的局限性 -- 训练误差仅反映模型在训练数据上的表现
      11. **过度拟合**的本质：当模型复杂度（如多项式次数）过高时，会 “拟合噪声而非数据底层规律”
12. 泛化能力的评估方法：交叉验证
    13. 核心逻辑：将数据分为训练集与测试集，用训练集构建模型后，在测试集上验证性能，测试误差更能反映泛化能力，且通常大于训练误差。
    14. 常用交叉验证策略：
        15. 留一法（Leave-one-out）：适用于小数据集，每次从原始数据中剔除 1 个样本作为测试集，剩余作为训练集，重复所有样本后取测试结果平均值。
        16. k 折交叉验证（k-fold）：适用于大数据集，将数据划分为 k 个等规模子集，每次用 k-1 个子集训练，1 个子集测试，循环 k 次后评估。
        17. 重复随机抽样验证：每次从数据中随机抽取 20%-50% 作为测试集，剩余为训练集，重复 k 次后取平均结果，降低随机划分带来的偏差。
18. 模型复杂度的平衡策略
    19. 理论指导优先若存在明确理论（如胡克定律表明弹簧受力与位移呈线性关系），即使高阶模型（如二次多项式）在训练数据上R^2更高，仍应优先选择符合理论的模型
    20. `无理论时的搜索流程：`
        21. 从低复杂度模型（如 1 次多项式）开始，在训练集上拟合
        22. 在测试集上验证并记录R^2
        23. 逐步提升模型复杂度，重复拟合与验证
        24. 当测试集R^2开始下降时，停止提升复杂度，选择此前最优模型
25. 课程核心结论 
    26. 线性回归的价值：可用于构建从自变量到因变量的映射模型，实现对未知数据的预测，但需结合模型复杂度控制
    27. `R^2的合理使用：R^2是评估模型拟合优度的重要指标，但 “更高的R^2” 不代表 “更优模型”，需警惕过度拟合导致的泛化能力下降`
    28. 模型选择三原则：
        29. 优先参考数据底层理论（如物理定律、业务逻辑）
        30. 用交叉验证验证模型泛化能力
        31. `在性能相近时，选择更简单的模型`

### 概率
1. Number systems（数字系统）：
   2. natural numbers ℕ，integers ℤ，rational numbers ℚ，real numbers ℝ
3. Closure（闭包）：
   4. Definition：Let 𝑋 be a set of numbers. We say that 𝑋 is：
      5. closed under addition（加法封闭） if 𝑥 + 𝑦 ∈ 𝑋 whenever 𝑥，𝑦 ∈ 𝑋
      6. closed under multiplication（乘法封闭） if 𝑥𝑦 ∈ 𝑋 whenever 𝑥，𝑦 ∈ 𝑋
      7. closed under subtraction（减法封闭） if 𝑥 − 𝑦 ∈ 𝑋 whenever 𝑥，𝑦 ∈ 𝑋
      8. closed under division（除法封闭） if 𝑥/𝑦 ∈ 𝑋 whenever 𝑥，𝑦 ∈ 𝑋 and 𝑦 ≠ 0
   9. 注意：要证明一个集合在某个运算下不是闭的，只要给出一个精心挑选的例子（反例）就足够了。但要证明它是闭包的，则需要一个一般的论证
   10. `一个严格的证明必须从定义开始`
11. Permutations（排列）
    12. Definition：A permutation of objects is an arrangement of these objects in a row `in some order`
    13. Theorem 1:The number of permutations, or ordered arrangements, of 𝑛 `distinct` objects is 𝑛(𝑛 − 1)(𝑛 − 2) ⋯ 2 ⋅ 1 = 𝑛!
    14. `Theorem 2:If 𝑛 objects consisting of 𝑐 classes of identical objects with size 𝑛1 , 𝑛2 , ⋯ , 𝑛C such that 𝑛1 + 𝑛2 + ⋯ + 𝑛C = 𝑛 , then the number of permutations of these 𝑛 objects is：𝑛! / 𝑛1!𝑛2!···𝑛C!`
        15. 多重集合的排列数公式的理解：如果n个元素完全不同，那么它们的排列数是 n!。现在的情况是：n个元素分为c类，同类元素完全相同，第i类有ni个元素，此时，“同类元素的重复” 会导致 “原本不同的排列被算成了相同的”，所以要除以每一类重复元素内部的排列数
    16. Theorem 3：The number of permutations, or ordered arrangements, of 𝑛 distinct objects taken 𝑟 at a time , where 𝑟 ≤ 𝑛, is given by：𝑃(n,r) = n(n-1)(n-2)···(n-r+1) = n! / (n-r)!
17. Combinations（组合）
    18. Theorem:Suppose we are now interested in the number of subsets of size 𝑟, where 𝑟 ≤ 𝑛, that can be chosen from 𝑛 distinct objects. The order of elements in each subset makes no difference.We denote as C(n,r) = n! / r!(n-r)!
    19. 注意：C(n,r) = C(n,n-r)
20. Probability of Counting:Permutations and combinations can be used in finding probabilities.
